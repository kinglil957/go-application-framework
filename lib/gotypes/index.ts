
import * as child_process from 'child_process';
import {
  EmitContext,
  EmitOptionsFor,
  Enum,
  EnumMember,
  IntrinsicType,
  Model,
  ModelProperty,
  Program,
  Scalar,
  Type,
  Union,
  UnionVariant,
  createTypeSpecLibrary,
  getDoc,
  paramMessage,
} from "@typespec/compiler";
import {
  CodeTypeEmitter,
  Context,
  EmittedSourceFile,
  EmitterOutput,
  SourceFile,
  StringBuilder,
  code,
} from "@typespec/compiler/emitter-framework";

export const TypeSpecGoTypesLibrary = createTypeSpecLibrary({
  name: "gotypes-emitter",
  diagnostics: {
    "unsupported-go-type": {
      severity: "error",
      messages: {
        default: `missing Go type mapping for Typespec type`,
      },
    },
  },
});

const { reportDiagnostic } = TypeSpecGoTypesLibrary;

/**
 * $onEmit is the main entrypoint for the "gotypes" Typespec emitter.
 */
export async function $onEmit(
  ctx: EmitContext<EmitOptionsFor<typeof TypeSpecGoTypesLibrary>>,
) {
  if (!ctx.program.compilerOptions.noEmit) {
    const assetEmitter = ctx.getAssetEmitter(GoTypesEmitter);
    assetEmitter.emitProgram();
    await assetEmitter.writeOutput();
    child_process.execSync(`go fmt ${ctx.emitterOutputDir}`);
  }
}

const intrinsicNameToGoType = new Map<string, string>([
  ["unknown", "any"],
  ["string", "string"],
  ["integer", "int"],
  ["int8", "int8"],
  ["int16", "int16"],
  ["int32", "int32"],
  ["int64", "int64"],
  ["uint8", "uint8"],
  ["uint16", "uint16"],
  ["uint32", "uint32"],
  ["uint64", "uint64"],
  ["float32", "float32"],
  ["float64", "float64"],
  ["numeric", "float64"],
  ["bytes", "[]byte"],
  ["boolean", "bool"],
]);

/**
 * GoTypesEmitter implements opinionated generation of Go structs from Typespec
 * types.
 */
class GoTypesEmitter extends CodeTypeEmitter {
  /**
   * sourceFile renders all declarations into a single Go source file's
   * contents.
   *
   * TODO: Go package name should be made configurable; for now it is
   * hard-coded.
   */
  sourceFile(sourceFile: SourceFile<string>): EmittedSourceFile | Promise<EmittedSourceFile> {
    // Collect all package imports that have been added and render them.
    const imports = [...sourceFile.imports.keys()].map(pkg => `\n\t"${pkg}"`).join('');

    const emittedSourceFile: EmittedSourceFile = {
      path: sourceFile.path,
      contents: `// Code generated by typespec.io tooling. DO NOT EDIT.

package presentation

import (${imports}
)
`,
    };

    for (const decl of sourceFile.globalScope.declarations) {
      emittedSourceFile.contents += decl.value + "\n\n";
    }

    return emittedSourceFile;
  }

  /**
   * programContext defines where the emitter's output will be written:
   * "models.gen.go" in the current working directory, which is typically the
   * directory containing main.tsp.
   */
  programContext(program: Program): Context {
    const sourceFile = this.emitter.createSourceFile("models.gen.go");
    return {
      scope: sourceFile.globalScope,
    };
  }

  /**
   * scalarDeclaration renders a Typespec scalar type as a Go type alias.
   */
  scalarDeclaration(scalar: Scalar, scalarName: string): EmitterOutput<string> {
    const doc = this.getDoc(scalar);
    if (intrinsicNameToGoType.has(scalarName)) {
      const code = intrinsicNameToGoType.get(scalarName)!;
      return this.emitter.result.rawCode(code);
    }
    if (scalar.baseScalar) {
      return this.emitter.result.declaration(scalarName, code`${doc}type ${scalar.name} = ${scalar.baseScalar.name}`);
    }
    reportDiagnostic(this.emitter.getProgram(), {
      code: "unsupported-go-type",
      target: scalar,
    });
    return this.emitter.result.none();
  }

  /**
   * intrinsic renders intrinsic (built-in) Typespec types as Go predeclared
   * types.
   */
  intrinsic(intrinsic: IntrinsicType, name: string): EmitterOutput<string> {
    if (!intrinsicNameToGoType.has(name)) {
      // TODO: use a compiler diagnostic error instead
      reportDiagnostic(this.emitter.getProgram(), {
        code: "unsupported-go-type",
        target: intrinsic,
      });
      return this.emitter.result.none();
    }

    const code = intrinsicNameToGoType.get(name)!;
    return this.emitter.result.rawCode(code);
  }

  /**
   * modelLiteral renders literal Typespec types as inline Go structs.
   *
   * Literal types aren't recommended.
   */
  modelLiteral(model: Model): EmitterOutput<string> {
    return this.emitter.result.rawCode(code`struct {${this.emitter.emitModelProperties(model)}
}`)
  }

  /**
   * getDoc returns the Go doc comment string for Typespec doc annotations.
   */
  getDoc(target: Type): string {
    const docText = getDoc(this.emitter.getProgram(), target);
    if (!docText) {
      return '';
    }
    return `// ${docText.replaceAll('\n', '\n// ')}\n`;
  }

  /**
   * modelDeclaration renders Typespec models as Go structs.
   */
  modelDeclaration(model: Model, name: string): EmitterOutput<string> {
    const doc = this.getDoc(model);
    const baseModel = model.baseModel?.name;
    const baseEmbed = baseModel ? `\n\t${baseModel}` : '';
    return this.emitter.result.declaration(name,
      code`${doc}type ${capitalize(name)} struct {${baseEmbed}${this.emitter.emitModelProperties(model)}
}`);
  }

  /**
   * modelPropertyLiteral renders a model property as a Go struct field.
   * Pointers are used to represent optional properties. JSON representation
   * follows Typespec names.
   *
   * TODO: decorators could be used to customize JSON, or automatically convert
   * to other case conventions (snake, etc).
   */
  modelPropertyLiteral(property: ModelProperty): EmitterOutput<string> {
    return this.emitter.result.rawCode(code`
\t${capitalize(property.name)} ${property.optional ? "*" : ""}${this.emitter.emitTypeReference(property.type)} \`json:"${property.name}"\``);
  }

  /**
   * modelProperties renders all of a model's properties as a concatenation of their rendered text.
   *
   * Without this override, properties are joined by commas in the base emitter implementation.
   */
  modelProperties(model: Model): EmitterOutput<string> {
    const builder = new StringBuilder();
    for (const prop of model.properties.values()) {
      builder.push(code`${this.emitter.emitModelProperty(prop)}`);
    }
    return this.emitter.result.rawCode(builder.reduce());
  }

  /**
   * enumDeclaration renders Typespec enums as a Go string type alias and constants.
   *
   * Go doesn't have first-class enum support.
   */
  enumDeclaration(en: Enum, name: string): EmitterOutput<string> {
    const doc = this.getDoc(en);
    return this.emitter.result.declaration(name, code`${doc}type ${name} = string
const (${this.emitter.emitEnumMembers(en)}
)
`);
  }

  /**
   * enumMember renders an enum member as a Go constant.
   * @param member
   * @returns
   */
  enumMember(member: EnumMember): EmitterOutput<string> {
    return this.emitter.result.rawCode(code`
\t${member.enum.name}${member.name} = ${member.enum.name}("${member.value as string ?? member.name}")`);
  }

  /**
   * enumMembers renders all of an enum's members as a concatenation of their rendered text.
   *
   * Without this override, members are joined by commas in the base emitter implementation.
   */
  enumMembers(en: Enum): EmitterOutput<string> {
    const builder = new StringBuilder();
    for (const member of en.members.values()) {
      builder.push(code`${this.enumMember(member)}`);
    }
    return this.emitter.result.rawCode(builder.reduce());
  }

  /**
   * arrayLiteral renders Typespec array types as Go slice types.
   */
  arrayLiteral(array: Model, elementType: Type): EmitterOutput<string> {
    return this.emitter.result.rawCode(code`[]${this.emitter.emitTypeReference(elementType)}`);
  }

  /**
   * unionLiteral handles literal, anonymous type unions in Typespec, which
   * aren't supported.
   */
  unionLiteral(union: Union): EmitterOutput<string> {
      reportDiagnostic(this.emitter.getProgram(), {
        code: "unsupported-go-type",
        target: union,
      });
      return this.emitter.result.none();
  }

  /**
   * unionDeclaration renders Typespec named unions as a Go struct of pointers to each variant.
   * Only one of these pointer members should be set.
   *
   * Json marshaling is supported by dispatching to the first non-nil member.
   *
   * TODO: Constructors could be used with private members, to help ensure
   * correct instantiation.
   *
   * TODO: Unmarshaling is currently unsupported. If/when it is supported, a
   * discriminator strategy will become necessary.
   */
  unionDeclaration(union: Union, name: string): EmitterOutput<string> {
    if (!union.name) {
      reportDiagnostic(this.emitter.getProgram(), {
        code: "unsupported-go-type",
        target: union,
      });
    }

    const doc = this.getDoc(union);
    this.emitter.getSourceFiles().forEach(sf => {
      sf.imports.set('encoding/json', []);
      sf.imports.set('fmt', []);
    });
    const variantCases = [...union.variants.values()].map(variant => capitalize(variant.name.toString())).map(name => `
  case m.${name} != nil:
    return json.Marshal(m.${name})`).join('');

    return this.emitter.result.declaration(name, code`${doc}type ${name} struct {${this.emitter.emitUnionVariants(union)}}

// MarshalJSON implements json.Marshaler for ${name}.
func (m *${name}) MarshalJSON() ([]byte, error) {
  switch {${variantCases}
  default:
    return nil, fmt.Errorf("uninitialized union type ${name}")
  }
}`);
  }

  /**
   * unionVariant renders a Typespec union member to a pointer field in a Go struct.
   */
  unionVariant(variant: UnionVariant): EmitterOutput<string> {
    return this.emitter.result.rawCode(code`
\t${capitalize(variant.name.toString())} *${this.emitter.emitTypeReference(variant.type)}`);
  }

  /**
   * unionVariants renders all of a union's variants as a concatenation of their rendered text.
   *
   * Without this override, variants are joined by commas in the base emitter implementation.
   */
  unionVariants(union: Union): EmitterOutput<string> {
    const builder = new StringBuilder();
    for (const variant of union.variants.values()) {
      builder.push(code`${this.unionVariant(variant)}`);
    }
    return this.emitter.result.rawCode(builder.reduce());
  }
}

/**
 * capitalize capitalizes the first character of a string.
 */
const capitalize = (s: string): string => {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
