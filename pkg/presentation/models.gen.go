// Code generated by typespec.io tooling. DO NOT EDIT.

package presentation

import (
	"encoding/json"
	"fmt"
)

// TestOutcome represents how the security test should be interpreted and acted
// upon. Did the test pass or fail according to findings, ignores and policy?
// Did an error interfere with the test making the results indeterminate?
type TestOutcome = string

const (
	TestOutcomePass  = TestOutcome("Pass")
	TestOutcomeFail  = TestOutcome("Fail")
	TestOutcomeError = TestOutcome("Error")
)

// FindingID uniquely identifies a Finding. It should be considered a stable
// primary key for a particular security finding on a particular asset.
type FindingID = string

// ScanType represents one of the security scan types supported by Snyk.
type ScanType = string

const (
	ScanTypeOpenSource = ScanType("OpenSource")
	ScanTypeContainer  = ScanType("Container")
	ScanTypeCode       = ScanType("Code")
	ScanTypeIaC        = ScanType("IaC")
)

// SourceFilePath represents an entire source file as the location of a Finding.
type SourceFilePath struct {
	Path string `json:"path"`
}

// SourceFileLine represents a single line within a source code file as the
// location of a Finding. Lines being delimited by newlines and/or carriage
// returns in a text file.
type SourceFileLine struct {
	SourceFilePath
	Line int `json:"line"`
}

// SourceFileRange represents a range of lines or characters within a source
// code text file as the location of a Finding.
type SourceFileRange struct {
	SourceFilePath
	StartLine   int  `json:"startLine"`
	StartColumn *int `json:"startColumn"`
	EndLine     int  `json:"endLine"`
	EndColumn   *int `json:"endColumn"`
}

// SourceFileLocation represents a source file location within an asset where a
// Finding was discovered.
type SourceFileLocation struct {
	EntireFile *SourceFilePath
	SingleLine *SourceFileLine
	Range      *SourceFileRange
}

// MarshalJSON implements json.Marshaler for SourceFileLocation.
func (m *SourceFileLocation) MarshalJSON() ([]byte, error) {
	switch {
	case m.EntireFile != nil:
		return json.Marshal(m.EntireFile)
	case m.SingleLine != nil:
		return json.Marshal(m.SingleLine)
	case m.Range != nil:
		return json.Marshal(m.Range)
	default:
		return nil, fmt.Errorf("uninitialized union type SourceFileLocation")
	}
}

// Vulnerability represents details about the security weakness of a Finding.
type Vulnerability struct {
}

// Remediation contains information about how to resolve or remediate the
// vulnerability of a Finding.
type Remediation struct {
}

// SeverityLevel enumerates the levels of impact severity.
type SeverityLevel = string

const (
	SeverityLevelCritical = SeverityLevel("Critical")
	SeverityLevelHigh     = SeverityLevel("High")
	SeverityLevelMedium   = SeverityLevel("Medium")
	SeverityLevelLow      = SeverityLevel("Low")
)

// Severity represents the overall impact of a security Finding.
type Severity struct {
	Level         SeverityLevel  `json:"level"`
	OriginalLevel *SeverityLevel `json:"originalLevel"`
}

// Ignore represents the application of a directive to ignore a particular
// Finding. This directive may have come from a developer or application
// security authority indicating the finding is a false positive or irrelevant
// to the application's threat model.
type Ignore struct {
	Ignored bool    `json:"ignored"`
	Reason  *string `json:"reason"`
}

// Finding represents an individual security vulnerability found by Snyk when
// scanning an asset, enriched with risk context and policy decisions.
type Finding struct {
	Id              FindingID          `json:"id"`
	ScanType        ScanType           `json:"scanType"`
	Location        SourceFileLocation `json:"location"`
	Vulnerabilities []Vulnerability    `json:"vulnerabilities"`
	Remediations    []Remediation      `json:"remediations"`
	Severity        Severity           `json:"severity"`
	Ignore          Ignore             `json:"ignore"`
}

// TestResult represents the top-level result from a Snyk security test. This
// includes the overall outcome and enriched findings.
type TestResult struct {
	Outcome  TestOutcome `json:"outcome"`
	ExitCode int         `json:"exitCode"`
	Findings []Finding   `json:"findings"`
}
